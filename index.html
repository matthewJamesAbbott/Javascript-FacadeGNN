<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Graph Neural Network with Facade</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 2rem;
        }

        input,
        select,
        textarea,
        button {
            margin: 0.5rem 0;
        }

        .section {
            margin-bottom: 2rem;
            border-bottom: 1px solid #ccc;
            padding-bottom: 1rem;
        }

        label {
            display: block;
            margin-top: 0.5rem;
        }

        .results {
            background-color: #f5f5f5;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
        }

        .metric {
            margin: 0.5rem 0;
            font-weight: bold;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .epoch-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .epoch-info {
            font-style: italic;
            color: #666;
            margin-top: 0.5rem;
        }

        .warning {
            color: #b36b00;
            background-color: #fff3cd;
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
        }

        .error-msg {
            color: #721c24;
            background-color: #f8d7da;
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
        }

        .facade-section {
            background-color: #e8f4f8;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .facade-controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.5rem;
        }

        .facade-output {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .histogram-container {
            display: flex;
            align-items: flex-end;
            height: 100px;
            border: 1px solid #ccc;
            margin: 0.5rem 0;
        }

        .histogram-bar {
            background-color: #4CAF50;
            flex: 1;
            margin: 0 1px;
        }

        textarea {
            width: 100%;
            font-family: monospace;
        }

        .inline-label {
            display: inline-block;
            margin-right: 1rem;
        }

        .graph-canvas-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            margin: 1rem 0;
            background: #fafafa;
        }

        #graphCanvas {
            display: block;
        }
    </style>
</head>

<body>
    <h1>Graph Neural Network with Facade</h1>

    <div class="section">
        <h2>Network Configuration</h2>
        <label class="inline-label">Feature Size: <input type="number" id="featureSize" value="3" min="1"></label>
        <label class="inline-label">Hidden Size: <input type="number" id="hiddenSize" value="16" min="4"></label>
        <label class="inline-label">Output Size: <input type="number" id="outputSize" value="2" min="1"></label>
        <label class="inline-label">MP Layers: <input type="number" id="numLayers" value="2" min="1" max="8"></label>
        <br>
        <label class="inline-label">Activation:
            <select id="activation">
                <option value="relu" selected>ReLU</option>
                <option value="leaky_relu">Leaky ReLU</option>
                <option value="tanh">Tanh</option>
                <option value="sigmoid">Sigmoid</option>
            </select>
        </label>
        <label class="inline-label">Loss Function:
            <select id="lossFunction">
                <option value="mse" selected>MSE</option>
                <option value="bce">Binary Cross-Entropy</option>
            </select>
        </label>
        <label class="inline-label">Learning Rate: <input type="number" id="learningRate" value="0.01" step="0.001" min="0.0001" max="1"></label>
        <br><br>
        <button onclick="createNetwork()">Create Network</button>
        <span id="networkStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Graph Configuration</h2>
        <label class="inline-label">Number of Nodes: <input type="number" id="numNodes" value="5" min="2" max="100"></label>
        <label class="inline-label"><input type="checkbox" id="undirected" checked> Undirected</label>
        <label class="inline-label"><input type="checkbox" id="selfLoops"> Self-Loops</label>
        <br><br>
        <label>Edges (source,target per line):</label>
        <textarea id="edgeList" rows="6">0,1
1,2
2,3
3,4
4,0
1,3</textarea>
        <br>
        <button onclick="buildGraph()">Build Graph</button>
        <button onclick="randomizeFeatures()">Randomize Features</button>
        <span id="graphStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Graph Visualization</h2>
        <div class="graph-canvas-container">
            <canvas id="graphCanvas" width="600" height="300"></canvas>
        </div>
    </div>

    <div class="section">
        <h2>Import Data from CSV</h2>
        <p style="color:#666; font-size:0.9rem;">Import node features and edges from CSV files, or paste data directly.</p>
        
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>
                <h4>Node Features CSV</h4>
                <p style="font-size:0.8rem; color:#888;">Format: nodeId,feature1,feature2,... (header optional)</p>
                <input type="file" id="nodesCsvFile" accept=".csv" onchange="loadNodesCsv(this)">
                <br>
                <label>Or paste directly:</label>
                <textarea id="nodesCsvText" rows="5" placeholder="0,0.5,0.3,0.2
1,0.1,0.8,0.4
2,0.9,0.2,0.6"></textarea>
            </div>
            <div>
                <h4>Edges CSV</h4>
                <p style="font-size:0.8rem; color:#888;">Format: source,target (header optional)</p>
                <input type="file" id="edgesCsvFile" accept=".csv" onchange="loadEdgesCsv(this)">
                <br>
                <label>Or paste directly:</label>
                <textarea id="edgesCsvText" rows="5" placeholder="0,1
1,2
2,0"></textarea>
            </div>
        </div>
        
        <h4>Training Targets CSV (for batch training)</h4>
        <p style="font-size:0.8rem; color:#888;">Format: target1,target2,... per line (one line per training sample/graph)</p>
        <input type="file" id="targetsCsvFile" accept=".csv" onchange="loadTargetsCsv(this)">
        <br>
        <label>Or paste directly:</label>
        <textarea id="targetsCsvText" rows="3" placeholder="1,0
0,1
1,0"></textarea>
        
        <br><br>
        <button onclick="importFromCsv()">Import from CSV/Text</button>
        <button onclick="clearCsvInputs()">Clear CSV Inputs</button>
        <span id="csvImportStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Manual Node Features Input</h2>
        <p style="color:#666; font-size:0.9rem;">Enter node features manually for the current graph (one node per line).</p>
        <textarea id="manualNodeFeatures" rows="6" placeholder="Enter features for each node, one per line:
0.5,0.3,0.2
0.1,0.8,0.4
0.9,0.2,0.6
0.4,0.5,0.1
0.7,0.3,0.8"></textarea>
        <br>
        <button onclick="applyManualFeatures()">Apply Node Features</button>
        <button onclick="loadCurrentFeatures()">Load Current Features</button>
        <span id="manualFeaturesStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Training</h2>
        <label class="inline-label">Target Output (comma separated): <input type="text" id="targetOutput" value="1,0" style="width:200px;"></label>
        <label class="inline-label">Training Iterations: <input type="number" id="trainIters" value="200" min="1" max="2000"></label>
        <br><br>
        <button onclick="trainNetwork()">Train</button>
        <button onclick="trainWithProgress()">Train with Progress</button>
        <button onclick="trainWithCsvTargets()">Train with CSV Targets</button>
        <button onclick="predictOnly()">Predict Only</button>
        <div id="trainStatus"></div>
        <div id="trainingProgress"></div>
        <div id="csvTargetsInfo" style="color:#666; font-size:0.9rem; margin-top:0.5rem;"></div>
    </div>

    <div class="section facade-section">
        <h2>ðŸ”§ GNN Facade API Explorer</h2>
        <p>Use the facade to inspect and modify the GNN internals:</p>

        <div class="facade-controls">
            <label>Node Index: <input type="number" id="facadeNodeIdx" value="0" min="0"></label>
            <label>Edge Index: <input type="number" id="facadeEdgeIdx" value="0" min="0"></label>
            <label>Layer Index: <input type="number" id="facadeLayerIdx" value="0" min="0"></label>
            <label>Feature Index: <input type="number" id="facadeFeatureIdx" value="0" min="0"></label>
            <label>Neighbor Index: <input type="number" id="facadeNeighborIdx" value="0" min="0"></label>
            <label>Neuron Index: <input type="number" id="facadeNeuronIdx" value="0" min="0"></label>
            <label>Weight Index: <input type="number" id="facadeWeightIdx" value="0" min="0"></label>
        </div>

        <h3>1. Node & Edge Features</h3>
        <button onclick="facadeGetNodeFeature()">Get Node Feature</button>
        <button onclick="facadeGetNodeFeatures()">Get All Node Features</button>
        <button onclick="facadeGetEdgeFeatures()">Get Edge Features</button>
        <button onclick="facadeGetNumNodes()">Get Num Nodes</button>
        <button onclick="facadeGetNumEdges()">Get Num Edges</button>

        <h3>2. Topology</h3>
        <button onclick="facadeGetNeighbors()">Get Neighbors</button>
        <button onclick="facadeGetAdjacencyMatrix()">Get Adjacency Matrix</button>
        <button onclick="facadeGetEdgeEndpoints()">Get Edge Endpoints</button>
        <button onclick="facadeHasEdge()">Has Edge?</button>
        <button onclick="facadeGetInDegree()">Get In-Degree</button>
        <button onclick="facadeGetOutDegree()">Get Out-Degree</button>

        <h3>3. Embeddings</h3>
        <button onclick="facadeGetNodeEmbedding()">Get Node Embedding</button>
        <button onclick="facadeGetAllNodeEmbeddings()">Get All Embeddings (Node)</button>
        <button onclick="facadeGetFinalEmbeddings()">Get Final Embeddings</button>
        <button onclick="facadeGetEdgeEmbedding()">Get Edge Embedding</button>
        <button onclick="facadeGetCurrentNodeEmbedding()">Get Current Embedding</button>

        <h3>4. Message Passing</h3>
        <button onclick="facadeGetMessage()">Get Message</button>
        <button onclick="facadeGetAggregatedMessage()">Get Aggregated Message</button>
        <button onclick="facadeGetMessageInput()">Get Message Input</button>
        <button onclick="facadeGetNumMessages()">Get Num Messages</button>

        <h3>5. Readout & Output</h3>
        <button onclick="facadeGetGraphEmbedding()">Get Graph Embedding</button>
        <button onclick="facadeGetReadoutOutput()">Get Readout Output</button>
        <button onclick="facadeGetOutputLayerOutput()">Get Output Layer Output</button>
        <button onclick="facadeGetPreActivations()">Get Pre-Activations</button>

        <h3>6. Gradients & Weights</h3>
        <button onclick="facadeGetWeightGradient()">Get Weight Gradient</button>
        <button onclick="facadeGetBiasGradient()">Get Bias Gradient</button>
        <button onclick="facadeGetMessageLayerWeight()">Get Msg Layer Weight</button>
        <button onclick="facadeGetUpdateLayerWeight()">Get Update Layer Weight</button>
        <button onclick="facadeGetGradientFlow()">Get Gradient Flow</button>
        <button onclick="facadeGetAllGradientFlows()">Get All Gradient Flows</button>

        <h3>7. Masking & Dropout</h3>
        <button onclick="facadeGetNodeMask()">Get Node Mask</button>
        <button onclick="facadeSetNodeMask()">Toggle Node Mask</button>
        <button onclick="facadeApplyNodeDropout()">Apply Node Dropout (30%)</button>
        <button onclick="facadeApplyEdgeDropout()">Apply Edge Dropout (30%)</button>
        <button onclick="facadeGetMaskedCounts()">Get Masked Counts</button>

        <h3>8. Graph Mutation</h3>
        <label class="inline-label">New Features: <input type="text" id="newNodeFeatures" value="0.5,0.5,0.5" style="width:100px;"></label>
        <button onclick="facadeAddNode()">Add Node</button>
        <button onclick="facadeRemoveNode()">Remove Node</button>
        <button onclick="facadeAddEdge()">Add Edge</button>
        <button onclick="facadeRemoveEdge()">Remove Edge</button>
        <button onclick="facadeClearEdges()">Clear All Edges</button>
        <button onclick="facadeRebuildAdjacency()">Rebuild Adjacency</button>

        <h3>9. Diagnostics & Centrality</h3>
        <button onclick="facadeGetNodeDegree()">Get Node Degree</button>
        <button onclick="facadeGetGraphCentrality()">Get Degree Centrality</button>
        <button onclick="facadeGetBetweennessCentrality()">Get Betweenness</button>
        <button onclick="facadeGetClosenessCentrality()">Get Closeness</button>
        <button onclick="facadeGetAttentionWeight()">Get Attention Weight</button>
        <button onclick="facadeComputePageRank()">Compute PageRank</button>
        <button onclick="facadeGetFeatureImportance()">Get Feature Importance</button>

        <h3>10. Batch Processing</h3>
        <button onclick="facadeAddToBatch()">Add Graph to Batch</button>
        <button onclick="facadeGetBatchSize()">Get Batch Size</button>
        <button onclick="facadeClearBatch()">Clear Batch</button>
        <button onclick="facadeGetBatchPredictions()">Get Batch Predictions</button>

        <h3>11. Visualization & Export</h3>
        <button onclick="facadeExportGraphJSON()">Export Graph JSON</button>
        <button onclick="facadeExportEmbeddingsCSV()">Export Embeddings CSV</button>
        <button onclick="facadeShowActivationHistogram()">Activation Histogram</button>
        <div id="histogramDisplay"></div>

        <h3>12. Architecture</h3>
        <button onclick="facadeGetLayerConfig()">Get Layer Config</button>
        <button onclick="facadeGetNumMPLayers()">Get Num MP Layers</button>
        <button onclick="facadeGetTotalLayers()">Get Total Layers</button>
        <button onclick="facadeGetParameterCount()">Get Parameter Count</button>
        <button onclick="facadeGetArchitectureSummary()">Get Architecture Summary</button>

        <h3>Setters</h3>
        <label class="inline-label">Value: <input type="number" id="facadeSetValue" value="0" step="0.01"></label>
        <button onclick="facadeSetNodeFeature()">Set Node Feature</button>
        <button onclick="facadeSetMessageLayerWeight()">Set Msg Weight</button>
        <button onclick="facadeSetLearningRate()">Set Learning Rate</button>

        <h3>Output</h3>
        <div id="facadeOutput" class="facade-output">Facade output will appear here...</div>
    </div>

    <div class="section">
        <h2>Predict</h2>
        <p style="color:#666; font-size:0.9rem;">Run prediction on current graph or enter custom node features below.</p>
        
        <h4>Predict with Current Graph</h4>
        <button onclick="predictOnly()">Run Prediction</button>
        
        <h4>Predict with Custom Input</h4>
        <label>Enter node features (one node per line, comma-separated):</label>
        <textarea id="predictInputFeatures" rows="5" placeholder="0.5,0.3,0.2
0.1,0.8,0.4
0.9,0.2,0.6"></textarea>
        <br>
        <label class="inline-label">Custom Edges (optional): <input type="text" id="predictInputEdges" placeholder="0,1;1,2;2,0" style="width:200px;"></label>
        <br>
        <button onclick="predictWithCustomInput()">Predict with Custom Input</button>
        
        <div id="predictOutput" class="results"></div>
    </div>

<script>
// ==================== CONFIGURATION ====================

const CONFIG = {
    MAX_NODES: 100,
    MAX_EDGES: 1000,
    MAX_ITERATIONS: 2000,
    HISTOGRAM_BINS: 20
};

// ==================== CORE DATA STRUCTURES ====================

class Edge {
    constructor(source, target) {
        this.source = source;
        this.target = target;
        this.features = [];
    }
    equals(other) {
        return this.source === other.source && this.target === other.target;
    }
    toKey() {
        return `${this.source}-${this.target}`;
    }
}

class Graph {
    constructor(numNodes) {
        this.numNodes = numNodes;
        this.nodeFeatures = Array(numNodes).fill(null).map(() => []);
        this.edges = [];
        this.adjacencyList = Array(numNodes).fill(null).map(() => []);
    }
    
    buildAdjacencyList(undirected = false, selfLoops = false) {
        this.adjacencyList = Array(this.numNodes).fill(null).map(() => []);
        
        for (const edge of this.edges) {
            this.adjacencyList[edge.source].push(edge.target);
            if (undirected && edge.source !== edge.target) {
                this.adjacencyList[edge.target].push(edge.source);
            }
        }
        
        if (selfLoops) {
            for (let i = 0; i < this.numNodes; i++) {
                if (!this.adjacencyList[i].includes(i)) {
                    this.adjacencyList[i].push(i);
                }
            }
        }
    }
    
    static deduplicateEdges(edges) {
        const seen = new Set();
        return edges.filter(e => {
            const key = e.toKey();
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }
}

// ==================== ACTIVATION FUNCTIONS ====================

const activations = {
    relu: {
        fn: x => Math.max(0, x),
        derivative: x => x > 0 ? 1 : 0
    },
    leaky_relu: {
        fn: x => x > 0 ? x : 0.01 * x,
        derivative: x => x > 0 ? 1 : 0.01
    },
    tanh: {
        fn: x => Math.tanh(x),
        derivative: x => 1 - Math.tanh(x) ** 2
    },
    sigmoid: {
        fn: x => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x)))),
        derivative: x => {
            const s = 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            return s * (1 - s);
        }
    }
};

// ==================== LOSS FUNCTIONS ====================

const lossFunctions = {
    mse: {
        fn: (pred, target) => {
            let sum = 0;
            for (let i = 0; i < pred.length; i++) {
                sum += (pred[i] - target[i]) ** 2;
            }
            return sum / pred.length;
        },
        derivative: (pred, target) => {
            return pred.map((p, i) => 2 * (p - target[i]) / pred.length);
        }
    },
    bce: {
        fn: (pred, target) => {
            let sum = 0;
            for (let i = 0; i < pred.length; i++) {
                const p = Math.max(1e-7, Math.min(1 - 1e-7, pred[i]));
                sum -= target[i] * Math.log(p) + (1 - target[i]) * Math.log(1 - p);
            }
            return sum / pred.length;
        },
        derivative: (pred, target) => {
            return pred.map((p, i) => {
                const pClamp = Math.max(1e-7, Math.min(1 - 1e-7, p));
                return (-target[i] / pClamp + (1 - target[i]) / (1 - pClamp)) / pred.length;
            });
        }
    }
};

// ==================== NEURAL NETWORK LAYERS ====================

class DenseLayer {
    constructor(numOutputs, numInputs) {
        this.numInputs = numInputs;
        this.numOutputs = numOutputs;
        
        const scale = Math.sqrt(2.0 / (numInputs + numOutputs));
        this.weights = Array(numOutputs).fill(null).map(() =>
            Array(numInputs).fill(0).map(() => (Math.random() - 0.5) * 2 * scale)
        );
        this.biases = Array(numOutputs).fill(0);
        
        this.lastInput = null;
        this.lastPreActivation = null;
        this.lastOutput = null;
        this.weightGrads = null;
        this.biasGrads = null;
    }
    
    forward(input, activation) {
        this.lastInput = input.slice();
        this.lastPreActivation = [];
        this.lastOutput = [];
        
        for (let i = 0; i < this.numOutputs; i++) {
            let sum = this.biases[i];
            for (let j = 0; j < this.numInputs; j++) {
                sum += this.weights[i][j] * input[j];
            }
            this.lastPreActivation[i] = sum;
            this.lastOutput[i] = activation.fn(sum);
        }
        
        return this.lastOutput;
    }
    
    backward(upstreamGrad, activation, learningRate) {
        const preActGrad = [];
        for (let i = 0; i < this.numOutputs; i++) {
            preActGrad[i] = upstreamGrad[i] * activation.derivative(this.lastPreActivation[i]);
        }
        
        this.weightGrads = Array(this.numOutputs).fill(null).map(() => Array(this.numInputs).fill(0));
        this.biasGrads = Array(this.numOutputs).fill(0);
        
        for (let i = 0; i < this.numOutputs; i++) {
            this.biasGrads[i] = preActGrad[i];
            for (let j = 0; j < this.numInputs; j++) {
                this.weightGrads[i][j] = preActGrad[i] * this.lastInput[j];
            }
        }
        
        const inputGrad = Array(this.numInputs).fill(0);
        for (let j = 0; j < this.numInputs; j++) {
            for (let i = 0; i < this.numOutputs; i++) {
                inputGrad[j] += this.weights[i][j] * preActGrad[i];
            }
        }
        
        for (let i = 0; i < this.numOutputs; i++) {
            this.biases[i] -= learningRate * this.biasGrads[i];
            for (let j = 0; j < this.numInputs; j++) {
                this.weights[i][j] -= learningRate * this.weightGrads[i][j];
            }
        }
        
        return inputGrad;
    }
    
    getWeights() {
        return { weights: this.weights.map(w => w.slice()), biases: this.biases.slice() };
    }
    
    setWeights(data) {
        this.weights = data.weights.map(w => w.slice());
        this.biases = data.biases.slice();
    }
}

// ==================== GRAPH NEURAL NETWORK ====================

class GraphNeuralNetwork {
    constructor(featureSize, hiddenSize, outputSize, numMPLayers) {
        this.featureSize = featureSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.numMPLayers = numMPLayers;
        this.learningRate = 0.01;
        this.activationType = 'relu';
        this.lossFunctionType = 'mse';
        
        this.messageLayers = [];
        this.updateLayers = [];
        
        for (let i = 0; i < numMPLayers; i++) {
            const inputSize = i === 0 ? featureSize * 2 : hiddenSize * 2;
            this.messageLayers.push(new DenseLayer(hiddenSize, inputSize));
            this.updateLayers.push(new DenseLayer(hiddenSize, hiddenSize * 2));
        }
        
        this.readoutLayer = new DenseLayer(hiddenSize, hiddenSize);
        this.outputLayer = new DenseLayer(outputSize, hiddenSize);
        
        this.nodeEmbeddings = [];
        this.embeddingHistory = [];
        this.messageHistory = [];
        this.aggregatedMessages = [];
        this.graphEmbedding = null;
        this.readoutOutput = null;
    }
    
    get activation() {
        return activations[this.activationType];
    }
    
    get lossFunction() {
        return lossFunctions[this.lossFunctionType];
    }
    
    forward(graph) {
        const N = graph.numNodes;
        const activation = this.activation;
        
        this.embeddingHistory = [];
        this.messageHistory = [];
        this.aggregatedMessages = [];
        
        let currentEmbeddings = graph.nodeFeatures.map(f => f.slice());
        this.embeddingHistory.push(currentEmbeddings.map(e => e.slice()));
        
        for (let layer = 0; layer < this.numMPLayers; layer++) {
            const newEmbeddings = [];
            const layerMessages = [];
            const layerAggregated = [];
            
            for (let node = 0; node < N; node++) {
                const neighbors = graph.adjacencyList[node];
                const nodeMessages = [];
                let aggregatedMessage = Array(this.hiddenSize).fill(0);
                
                if (neighbors.length > 0) {
                    for (const neighbor of neighbors) {
                        const concat = currentEmbeddings[node].concat(currentEmbeddings[neighbor]);
                        const message = this.messageLayers[layer].forward(concat, activation);
                        nodeMessages.push({ neighbor, message: message.slice(), concat: concat.slice() });
                        
                        for (let i = 0; i < this.hiddenSize; i++) {
                            aggregatedMessage[i] += message[i];
                        }
                    }
                    
                    for (let i = 0; i < this.hiddenSize; i++) {
                        aggregatedMessage[i] /= neighbors.length;
                    }
                }
                
                layerMessages.push(nodeMessages);
                layerAggregated.push(aggregatedMessage);
                
                let updateInput;
                if (layer === 0) {
                    const paddedFeatures = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < Math.min(currentEmbeddings[node].length, this.hiddenSize); i++) {
                        paddedFeatures[i] = currentEmbeddings[node][i];
                    }
                    updateInput = paddedFeatures.concat(aggregatedMessage);
                } else {
                    updateInput = currentEmbeddings[node].concat(aggregatedMessage);
                }
                
                const newEmb = this.updateLayers[layer].forward(updateInput, activation);
                newEmbeddings.push(newEmb);
            }
            
            this.messageHistory.push(layerMessages);
            this.aggregatedMessages.push(layerAggregated);
            currentEmbeddings = newEmbeddings;
            this.embeddingHistory.push(currentEmbeddings.map(e => e.slice()));
        }
        
        this.nodeEmbeddings = currentEmbeddings;
        
        this.graphEmbedding = Array(this.hiddenSize).fill(0);
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < this.hiddenSize; j++) {
                this.graphEmbedding[j] += this.nodeEmbeddings[i][j];
            }
        }
        for (let j = 0; j < this.hiddenSize; j++) {
            this.graphEmbedding[j] /= N;
        }
        
        this.readoutOutput = this.readoutLayer.forward(this.graphEmbedding, activation);
        const output = this.outputLayer.forward(this.readoutOutput, activations.sigmoid);
        
        return output;
    }
    
    backward(graph, target) {
        const N = graph.numNodes;
        const activation = this.activation;
        const lr = this.learningRate;
        
        const prediction = this.outputLayer.lastOutput;
        const lossGrad = this.lossFunction.derivative(prediction, target);
        
        const readoutGrad = this.outputLayer.backward(lossGrad, activations.sigmoid, lr);
        const graphEmbGrad = this.readoutLayer.backward(readoutGrad, activation, lr);
        
        const nodeGrads = Array(N).fill(null).map(() => 
            graphEmbGrad.map(g => g / N)
        );
        
        for (let layer = this.numMPLayers - 1; layer >= 0; layer--) {
            const prevEmbeddings = this.embeddingHistory[layer];
            const newNodeGrads = Array(N).fill(null).map(() => 
                Array(layer === 0 ? this.featureSize : this.hiddenSize).fill(0)
            );
            
            for (let node = 0; node < N; node++) {
                let updateInput;
                if (layer === 0) {
                    const paddedFeatures = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < Math.min(prevEmbeddings[node].length, this.hiddenSize); i++) {
                        paddedFeatures[i] = prevEmbeddings[node][i];
                    }
                    updateInput = paddedFeatures.concat(this.aggregatedMessages[layer][node]);
                } else {
                    updateInput = prevEmbeddings[node].concat(this.aggregatedMessages[layer][node]);
                }
                
                this.updateLayers[layer].lastInput = updateInput;
                const updateInputGrad = this.updateLayers[layer].backward(nodeGrads[node], activation, lr);
                
                for (let i = 0; i < Math.min(this.hiddenSize, newNodeGrads[node].length); i++) {
                    if (layer === 0 && i < this.featureSize) {
                        newNodeGrads[node][i] += updateInputGrad[i];
                    } else if (layer > 0) {
                        newNodeGrads[node][i] += updateInputGrad[i];
                    }
                }
                
                const numNeighbors = graph.adjacencyList[node].length;
                if (numNeighbors > 0) {
                    const msgGrad = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < this.hiddenSize; i++) {
                        msgGrad[i] = updateInputGrad[this.hiddenSize + i] / numNeighbors;
                    }
                    
                    for (const msgInfo of this.messageHistory[layer][node]) {
                        this.messageLayers[layer].lastInput = msgInfo.concat;
                        const concatGrad = this.messageLayers[layer].backward(msgGrad, activation, lr);
                        
                        const halfLen = concatGrad.length / 2;
                        for (let i = 0; i < Math.min(halfLen, newNodeGrads[node].length); i++) {
                            newNodeGrads[node][i] += concatGrad[i];
                        }
                        for (let i = 0; i < Math.min(halfLen, newNodeGrads[msgInfo.neighbor].length); i++) {
                            newNodeGrads[msgInfo.neighbor][i] += concatGrad[halfLen + i];
                        }
                    }
                }
            }
            
            if (layer > 0) {
                for (let node = 0; node < N; node++) {
                    nodeGrads[node] = newNodeGrads[node];
                }
            }
        }
    }
    
    train(graph, target) {
        const prediction = this.forward(graph);
        const loss = this.lossFunction.fn(prediction, target);
        this.backward(graph, target);
        return { prediction, loss };
    }
    
    predict(graph) {
        return this.forward(graph);
    }
    
    getWeights() {
        return {
            messageLayers: this.messageLayers.map(l => l.getWeights()),
            updateLayers: this.updateLayers.map(l => l.getWeights()),
            readoutLayer: this.readoutLayer.getWeights(),
            outputLayer: this.outputLayer.getWeights(),
            config: {
                featureSize: this.featureSize,
                hiddenSize: this.hiddenSize,
                outputSize: this.outputSize,
                numMPLayers: this.numMPLayers
            }
        };
    }
    
    setWeights(data) {
        data.messageLayers.forEach((w, i) => this.messageLayers[i].setWeights(w));
        data.updateLayers.forEach((w, i) => this.updateLayers[i].setWeights(w));
        this.readoutLayer.setWeights(data.readoutLayer);
        this.outputLayer.setWeights(data.outputLayer);
    }
}

// ==================== GNN FACADE ====================

class GNNFacade {
    constructor(featureSize, hiddenSize, outputSize, numMPLayers) {
        this.gnn = new GraphNeuralNetwork(featureSize, hiddenSize, outputSize, numMPLayers);
        this.graph = null;
        this.graphLoaded = false;
        this.nodeMasks = [];
        this.edgeMasks = [];
        this.graphEmbeddingHistory = [];
        this.batchGraphs = [];
        this.batchNodeEmbeddings = [];
        this.messagePassingTrace = [];
        this.traceEnabled = false;
    }
    
    _ensureGraphLoaded() {
        if (!this.graphLoaded) throw new Error('No graph loaded.');
    }
    
    _initializeMasks() {
        this.nodeMasks = Array(this.graph.numNodes).fill(true);
        this.edgeMasks = Array(this.graph.edges.length).fill(true);
    }
    
    // Graph Management
    loadGraph(graph) {
        this.graph = graph;
        this.graphLoaded = true;
        this._initializeMasks();
    }
    
    createEmptyGraph(numNodes, featureSize) {
        this.graph = new Graph(numNodes);
        for (let i = 0; i < numNodes; i++) {
            this.graph.nodeFeatures[i] = Array(featureSize).fill(0);
        }
        this.graphLoaded = true;
        this._initializeMasks();
    }
    
    getGraph() { this._ensureGraphLoaded(); return this.graph; }
    
    // 1. Node and Edge Feature Access
    getNodeFeature(nodeIdx, featureIdx) {
        this._ensureGraphLoaded();
        return this.graph.nodeFeatures[nodeIdx]?.[featureIdx] ?? 0;
    }
    
    setNodeFeature(nodeIdx, featureIdx, value) {
        this._ensureGraphLoaded();
        if (this.graph.nodeFeatures[nodeIdx]) {
            this.graph.nodeFeatures[nodeIdx][featureIdx] = value;
        }
    }
    
    getNodeFeatures(nodeIdx) {
        this._ensureGraphLoaded();
        return (this.graph.nodeFeatures[nodeIdx] || []).slice();
    }
    
    setNodeFeatures(nodeIdx, features) {
        this._ensureGraphLoaded();
        this.graph.nodeFeatures[nodeIdx] = features.slice();
    }
    
    getEdgeFeatures(edgeIdx) {
        this._ensureGraphLoaded();
        return (this.graph.edges[edgeIdx]?.features || []).slice();
    }
    
    getNumNodes() { this._ensureGraphLoaded(); return this.graph.numNodes; }
    getNumEdges() { this._ensureGraphLoaded(); return this.graph.edges.length; }
    
    // 2. Topology
    getNeighbors(nodeIdx) {
        this._ensureGraphLoaded();
        return (this.graph.adjacencyList[nodeIdx] || []).slice();
    }
    
    getAdjacencyMatrix() {
        this._ensureGraphLoaded();
        const n = this.graph.numNodes;
        const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (const j of (this.graph.adjacencyList[i] || [])) {
                matrix[i][j] = 1;
            }
        }
        return matrix;
    }
    
    getEdgeEndpoints(edgeIdx) {
        this._ensureGraphLoaded();
        const e = this.graph.edges[edgeIdx];
        return e ? { source: e.source, target: e.target } : null;
    }
    
    hasEdge(source, target) {
        this._ensureGraphLoaded();
        return this.graph.edges.some(e => e.source === source && e.target === target);
    }
    
    findEdgeIndex(source, target) {
        this._ensureGraphLoaded();
        return this.graph.edges.findIndex(e => e.source === source && e.target === target);
    }
    
    getInDegree(nodeIdx) {
        this._ensureGraphLoaded();
        return this.graph.edges.filter(e => e.target === nodeIdx).length;
    }
    
    getOutDegree(nodeIdx) {
        this._ensureGraphLoaded();
        return this.graph.edges.filter(e => e.source === nodeIdx).length;
    }
    
    // 3. Embeddings
    getNodeEmbedding(layerIdx, nodeIdx) {
        if (!this.gnn.embeddingHistory?.length) return [];
        return (this.gnn.embeddingHistory[layerIdx]?.[nodeIdx] || []).slice();
    }
    
    getAllNodeEmbeddings(nodeIdx) {
        if (!this.gnn.embeddingHistory?.length) return [];
        return this.gnn.embeddingHistory.map(layer => (layer[nodeIdx] || []).slice());
    }
    
    getFinalNodeEmbeddings() {
        return (this.gnn.nodeEmbeddings || []).map(e => e.slice());
    }
    
    getEdgeEmbedding(layerIdx, edgeIdx) {
        if (!this.gnn.messageHistory?.length) return [];
        const edge = this.graph?.edges[edgeIdx];
        if (!edge) return [];
        const msgs = this.gnn.messageHistory[layerIdx]?.[edge.source] || [];
        const msg = msgs.find(m => m.neighbor === edge.target);
        return msg ? msg.message.slice() : [];
    }
    
    getCurrentNodeEmbedding(nodeIdx) {
        return (this.gnn.nodeEmbeddings?.[nodeIdx] || []).slice();
    }
    
    // 4. Message Passing
    getMessage(nodeIdx, neighborIdx, layerIdx) {
        if (!this.gnn.messageHistory?.length) return [];
        const msgs = this.gnn.messageHistory[layerIdx]?.[nodeIdx] || [];
        const msg = msgs.find(m => m.neighbor === neighborIdx);
        return msg ? msg.message.slice() : [];
    }
    
    getAggregatedMessage(nodeIdx, layerIdx) {
        if (!this.gnn.aggregatedMessages?.length) return [];
        return (this.gnn.aggregatedMessages[layerIdx]?.[nodeIdx] || []).slice();
    }
    
    getMessageInput(nodeIdx, neighborIdx, layerIdx) {
        if (!this.gnn.messageHistory?.length) return [];
        const msgs = this.gnn.messageHistory[layerIdx]?.[nodeIdx] || [];
        const msg = msgs.find(m => m.neighbor === neighborIdx);
        return msg ? msg.concat.slice() : [];
    }
    
    getNumMessagesForNode(nodeIdx, layerIdx) {
        if (!this.gnn.messageHistory?.length) return 0;
        return this.gnn.messageHistory[layerIdx]?.[nodeIdx]?.length || 0;
    }
    
    // 5. Readout & Output
    getGraphEmbedding() {
        return (this.gnn.graphEmbedding || []).slice();
    }
    
    getReadoutLayerOutput() {
        return (this.gnn.readoutOutput || []).slice();
    }
    
    getOutputLayerOutput() {
        return (this.gnn.outputLayer?.lastOutput || []).slice();
    }
    
    getReadoutLayerPreActivations() {
        return (this.gnn.readoutLayer?.lastPreActivation || []).slice();
    }
    
    getOutputLayerPreActivations() {
        return (this.gnn.outputLayer?.lastPreActivation || []).slice();
    }
    
    // 6. Gradients & Weights
    _getLayerByIndex(layerIdx) {
        const numMP = this.gnn.numMPLayers;
        if (layerIdx < numMP) return this.gnn.messageLayers[layerIdx];
        if (layerIdx < numMP * 2) return this.gnn.updateLayers[layerIdx - numMP];
        if (layerIdx === numMP * 2) return this.gnn.readoutLayer;
        if (layerIdx === numMP * 2 + 1) return this.gnn.outputLayer;
        return null;
    }
    
    getWeightGradient(layerIdx, neuronIdx, weightIdx) {
        const layer = this._getLayerByIndex(layerIdx);
        return layer?.weightGrads?.[neuronIdx]?.[weightIdx] ?? 0;
    }
    
    getBiasGradient(layerIdx, neuronIdx) {
        const layer = this._getLayerByIndex(layerIdx);
        return layer?.biasGrads?.[neuronIdx] ?? 0;
    }
    
    getMessageLayerWeight(layerIdx, neuronIdx, weightIdx) {
        return this.gnn.messageLayers[layerIdx]?.weights?.[neuronIdx]?.[weightIdx] ?? 0;
    }
    
    setMessageLayerWeight(layerIdx, neuronIdx, weightIdx, value) {
        if (this.gnn.messageLayers[layerIdx]?.weights?.[neuronIdx]) {
            this.gnn.messageLayers[layerIdx].weights[neuronIdx][weightIdx] = value;
        }
    }
    
    getUpdateLayerWeight(layerIdx, neuronIdx, weightIdx) {
        return this.gnn.updateLayers[layerIdx]?.weights?.[neuronIdx]?.[weightIdx] ?? 0;
    }
    
    getGradientFlow(layerIdx) {
        const layer = this._getLayerByIndex(layerIdx);
        if (!layer?.weightGrads) return { layerIdx, meanGradient: 0, maxGradient: 0, minGradient: 0, gradientNorm: 0 };
        
        let sum = 0, count = 0, maxG = -Infinity, minG = Infinity, normSq = 0;
        for (const row of layer.weightGrads) {
            for (const g of row) {
                sum += g; count++; normSq += g * g;
                if (g > maxG) maxG = g;
                if (g < minG) minG = g;
            }
        }
        return {
            layerIdx,
            meanGradient: count > 0 ? sum / count : 0,
            maxGradient: maxG === -Infinity ? 0 : maxG,
            minGradient: minG === Infinity ? 0 : minG,
            gradientNorm: Math.sqrt(normSq)
        };
    }
    
    getAllGradientFlows() {
        const total = this.gnn.numMPLayers * 2 + 2;
        return Array(total).fill(0).map((_, i) => this.getGradientFlow(i));
    }
    
    // 7. Masking
    getNodeMask(nodeIdx) { return this.nodeMasks[nodeIdx] ?? true; }
    setNodeMask(nodeIdx, value) { if (nodeIdx < this.nodeMasks.length) this.nodeMasks[nodeIdx] = value; }
    getEdgeMask(edgeIdx) { return this.edgeMasks[edgeIdx] ?? true; }
    setEdgeMask(edgeIdx, value) { if (edgeIdx < this.edgeMasks.length) this.edgeMasks[edgeIdx] = value; }
    getMaskedNodeCount() { return this.nodeMasks.filter(m => !m).length; }
    getMaskedEdgeCount() { return this.edgeMasks.filter(m => !m).length; }
    
    applyDropoutToNodes(rate) {
        for (let i = 0; i < this.nodeMasks.length; i++) {
            this.nodeMasks[i] = Math.random() >= rate;
        }
    }
    
    applyDropoutToEdges(rate) {
        for (let i = 0; i < this.edgeMasks.length; i++) {
            this.edgeMasks[i] = Math.random() >= rate;
        }
    }
    
    // 8. Graph Mutation
    addNode(features) {
        this._ensureGraphLoaded();
        const idx = this.graph.numNodes++;
        this.graph.nodeFeatures.push(features.slice());
        this.graph.adjacencyList.push([]);
        this.nodeMasks.push(true);
        return idx;
    }
    
    removeNode(nodeIdx) {
        this._ensureGraphLoaded();
        this.graph.edges = this.graph.edges.filter(e => e.source !== nodeIdx && e.target !== nodeIdx);
        for (const e of this.graph.edges) {
            if (e.source > nodeIdx) e.source--;
            if (e.target > nodeIdx) e.target--;
        }
        this.graph.nodeFeatures.splice(nodeIdx, 1);
        this.graph.adjacencyList.splice(nodeIdx, 1);
        this.nodeMasks.splice(nodeIdx, 1);
        this.graph.numNodes--;
        for (let i = 0; i < this.graph.adjacencyList.length; i++) {
            this.graph.adjacencyList[i] = this.graph.adjacencyList[i]
                .filter(n => n !== nodeIdx).map(n => n > nodeIdx ? n - 1 : n);
        }
        this.edgeMasks = Array(this.graph.edges.length).fill(true);
    }
    
    addEdge(source, target, features = []) {
        this._ensureGraphLoaded();
        const edge = new Edge(source, target);
        edge.features = features.slice();
        this.graph.edges.push(edge);
        this.edgeMasks.push(true);
        if (!this.graph.adjacencyList[source].includes(target)) {
            this.graph.adjacencyList[source].push(target);
        }
        return this.graph.edges.length - 1;
    }
    
    removeEdge(edgeIdx) {
        this._ensureGraphLoaded();
        const edge = this.graph.edges[edgeIdx];
        if (edge) {
            const adjIdx = this.graph.adjacencyList[edge.source].indexOf(edge.target);
            if (adjIdx !== -1) this.graph.adjacencyList[edge.source].splice(adjIdx, 1);
            this.graph.edges.splice(edgeIdx, 1);
            this.edgeMasks.splice(edgeIdx, 1);
        }
    }
    
    clearAllEdges() {
        this._ensureGraphLoaded();
        this.graph.edges = [];
        this.edgeMasks = [];
        for (let i = 0; i < this.graph.numNodes; i++) this.graph.adjacencyList[i] = [];
    }
    
    rebuildAdjacencyList(undirected = false, selfLoops = false) {
        this._ensureGraphLoaded();
        this.graph.buildAdjacencyList(undirected, selfLoops);
    }
    
    // 9. Diagnostics
    getNodeDegree(nodeIdx) {
        this._ensureGraphLoaded();
        return this.graph.adjacencyList[nodeIdx]?.length || 0;
    }
    
    getGraphCentrality(nodeIdx) {
        this._ensureGraphLoaded();
        const n = this.graph.numNodes;
        return n > 1 ? this.getNodeDegree(nodeIdx) / (n - 1) : 0;
    }
    
    getBetweennessCentrality(nodeIdx) {
        this._ensureGraphLoaded();
        const n = this.graph.numNodes;
        if (n <= 2) return 0;
        let total = 0, through = 0;
        for (let s = 0; s < n; s++) {
            if (s === nodeIdx) continue;
            for (let t = 0; t < n; t++) {
                if (t === nodeIdx || t === s) continue;
                const paths = this._countShortestPaths(s, t, nodeIdx);
                total += paths.total;
                through += paths.through;
            }
        }
        return total > 0 ? through / total : 0;
    }
    
    _countShortestPaths(source, target, through) {
        const n = this.graph.numNodes;
        const dist = Array(n).fill(-1);
        const count = Array(n).fill(0);
        const countThrough = Array(n).fill(0);
        dist[source] = 0; count[source] = 1;
        const queue = [source];
        while (queue.length > 0) {
            const node = queue.shift();
            for (const neighbor of (this.graph.adjacencyList[node] || [])) {
                if (dist[neighbor] === -1) {
                    dist[neighbor] = dist[node] + 1;
                    queue.push(neighbor);
                }
                if (dist[neighbor] === dist[node] + 1) {
                    count[neighbor] += count[node];
                    if (node === through || countThrough[node] > 0) {
                        countThrough[neighbor] += count[node];
                    }
                }
            }
        }
        return { total: count[target], through: countThrough[target] };
    }
    
    getClosenessCentrality(nodeIdx) {
        this._ensureGraphLoaded();
        const n = this.graph.numNodes;
        if (n <= 1) return 0;
        const dist = Array(n).fill(-1);
        dist[nodeIdx] = 0;
        const queue = [nodeIdx];
        while (queue.length > 0) {
            const node = queue.shift();
            for (const neighbor of (this.graph.adjacencyList[node] || [])) {
                if (dist[neighbor] === -1) {
                    dist[neighbor] = dist[node] + 1;
                    queue.push(neighbor);
                }
            }
        }
        let sumDist = 0, reachable = 0;
        for (let i = 0; i < n; i++) {
            if (i !== nodeIdx && dist[i] !== -1) {
                sumDist += dist[i];
                reachable++;
            }
        }
        return sumDist > 0 ? reachable / sumDist : 0;
    }
    
    getAttentionWeight(nodeIdx, neighborIdx, layerIdx) {
        const msg = this.getMessage(nodeIdx, neighborIdx, layerIdx);
        if (!msg.length) return 0;
        const mag = Math.sqrt(msg.reduce((s, v) => s + v * v, 0));
        const neighbors = this.getNeighbors(nodeIdx);
        if (!neighbors.length) return 0;
        let totalMag = 0;
        for (const n of neighbors) {
            const nMsg = this.getMessage(nodeIdx, n, layerIdx);
            totalMag += Math.sqrt(nMsg.reduce((s, v) => s + v * v, 0));
        }
        return totalMag > 0 ? mag / totalMag : 1 / neighbors.length;
    }
    
    computePageRank(damping = 0.85, iterations = 100) {
        this._ensureGraphLoaded();
        const n = this.graph.numNodes;
        if (n === 0) return [];
        let ranks = Array(n).fill(1 / n);
        const newRanks = Array(n).fill(0);
        for (let iter = 0; iter < iterations; iter++) {
            for (let i = 0; i < n; i++) newRanks[i] = (1 - damping) / n;
            for (let i = 0; i < n; i++) {
                const neighbors = this.graph.adjacencyList[i] || [];
                const outDeg = neighbors.length;
                if (outDeg > 0) {
                    for (const j of neighbors) newRanks[j] += damping * ranks[i] / outDeg;
                } else {
                    for (let j = 0; j < n; j++) newRanks[j] += damping * ranks[i] / n;
                }
            }
            const sum = newRanks.reduce((s, v) => s + v, 0);
            for (let i = 0; i < n; i++) ranks[i] = newRanks[i] / sum;
        }
        return ranks;
    }
    
    getFeatureImportance(nodeIdx, featureIdx) {
        const features = this.getNodeFeatures(nodeIdx);
        if (featureIdx >= features.length) return 0;
        const sum = features.reduce((s, v) => s + Math.abs(v), 0);
        return sum > 0 ? Math.abs(features[featureIdx]) / sum : 0;
    }
    
    // 10. Batch
    addGraphToBatch(graph) {
        this.batchGraphs.push(graph);
        this.batchNodeEmbeddings.push([]);
    }
    
    getBatchSize() { return this.batchGraphs.length; }
    clearBatch() { this.batchGraphs = []; this.batchNodeEmbeddings = []; }
    
    getBatchPredictions() {
        const preds = [];
        for (const g of this.batchGraphs) {
            this.loadGraph(g);
            preds.push(this.predict());
        }
        return preds;
    }
    
    // 11. Export
    exportGraphToJSON() {
        this._ensureGraphLoaded();
        return JSON.stringify({
            numNodes: this.graph.numNodes,
            nodes: this.graph.nodeFeatures.map((f, i) => ({ id: i, features: f, masked: !this.nodeMasks[i] })),
            edges: this.graph.edges.map((e, i) => ({ source: e.source, target: e.target, features: e.features || [], masked: !this.edgeMasks[i] }))
        }, null, 2);
    }
    
    exportEmbeddingsToCSV(layerIdx) {
        if (!this.gnn.embeddingHistory?.length) return '';
        const embeddings = this.gnn.embeddingHistory[layerIdx];
        if (!embeddings?.length) return '';
        const numDims = embeddings[0].length;
        const header = Array(numDims).fill(0).map((_, i) => `dim_${i}`).join(',');
        const rows = embeddings.map(e => e.map(v => v.toFixed(6)).join(','));
        return header + '\n' + rows.join('\n');
    }
    
    getActivationHistogram(layerIdx, numBins = CONFIG.HISTOGRAM_BINS) {
        if (!this.gnn.embeddingHistory?.length) return Array(numBins).fill(0);
        const embeddings = this.gnn.embeddingHistory[layerIdx];
        if (!embeddings) return Array(numBins).fill(0);
        const activations = [];
        for (const nodeEmb of embeddings) {
            for (const val of nodeEmb) activations.push(val);
        }
        if (!activations.length) return Array(numBins).fill(0);
        const minVal = Math.min(...activations);
        const maxVal = Math.max(...activations);
        if (maxVal === minVal) { const r = Array(numBins).fill(0); r[0] = 1; return r; }
        const binWidth = (maxVal - minVal) / numBins;
        const hist = Array(numBins).fill(0);
        for (const val of activations) {
            let idx = Math.floor((val - minVal) / binWidth);
            if (idx >= numBins) idx = numBins - 1;
            if (idx < 0) idx = 0;
            hist[idx]++;
        }
        return hist.map(c => c / activations.length);
    }
    
    // 12. Architecture
    getLayerConfig(layerIdx) {
        const numMP = this.gnn.numMPLayers;
        if (layerIdx < numMP) {
            const l = this.gnn.messageLayers[layerIdx];
            return { layerType: 'Message', numInputs: l.numInputs, numOutputs: l.numOutputs, activationType: this.gnn.activationType };
        } else if (layerIdx < numMP * 2) {
            const l = this.gnn.updateLayers[layerIdx - numMP];
            return { layerType: 'Update', numInputs: l.numInputs, numOutputs: l.numOutputs, activationType: this.gnn.activationType };
        } else if (layerIdx === numMP * 2) {
            return { layerType: 'Readout', numInputs: this.gnn.readoutLayer.numInputs, numOutputs: this.gnn.readoutLayer.numOutputs, activationType: this.gnn.activationType };
        } else if (layerIdx === numMP * 2 + 1) {
            return { layerType: 'Output', numInputs: this.gnn.outputLayer.numInputs, numOutputs: this.gnn.outputLayer.numOutputs, activationType: 'sigmoid' };
        }
        return { layerType: 'Unknown', numInputs: 0, numOutputs: 0, activationType: 'unknown' };
    }
    
    getNumMessagePassingLayers() { return this.gnn.numMPLayers; }
    getTotalLayerCount() { return this.gnn.numMPLayers * 2 + 2; }
    
    getParameterCount() {
        let count = 0;
        for (const l of this.gnn.messageLayers) {
            for (let i = 0; i < l.numOutputs; i++) count += l.weights[i].length + 1;
        }
        for (const l of this.gnn.updateLayers) {
            for (let i = 0; i < l.numOutputs; i++) count += l.weights[i].length + 1;
        }
        for (let i = 0; i < this.gnn.readoutLayer.numOutputs; i++) count += this.gnn.readoutLayer.weights[i].length + 1;
        for (let i = 0; i < this.gnn.outputLayer.numOutputs; i++) count += this.gnn.outputLayer.weights[i].length + 1;
        return count;
    }
    
    getArchitectureSummary() {
        const numMP = this.gnn.numMPLayers;
        let s = '=== GNN Architecture Summary ===\n';
        s += `Feature Size: ${this.gnn.featureSize}\n`;
        s += `Hidden Size: ${this.gnn.hiddenSize}\n`;
        s += `Output Size: ${this.gnn.outputSize}\n`;
        s += `Message Passing Layers: ${numMP}\n`;
        s += `Activation: ${this.gnn.activationType}\n`;
        s += `Learning Rate: ${this.gnn.learningRate.toFixed(6)}\n`;
        s += `Total Parameters: ${this.getParameterCount()}\n\n`;
        s += '--- Layer Details ---\n';
        for (let i = 0; i < numMP; i++) {
            const msg = this.gnn.messageLayers[i];
            const upd = this.gnn.updateLayers[i];
            s += `Message Layer ${i}: ${msg.numInputs} inputs, ${msg.numOutputs} outputs\n`;
            s += `Update Layer ${i}: ${upd.numInputs} inputs, ${upd.numOutputs} outputs\n`;
        }
        s += `Readout Layer: ${this.gnn.readoutLayer.numInputs} inputs, ${this.gnn.readoutLayer.numOutputs} outputs\n`;
        s += `Output Layer: ${this.gnn.outputLayer.numInputs} inputs, ${this.gnn.outputLayer.numOutputs} outputs\n`;
        return s;
    }
    
    // Core operations
    predict() { this._ensureGraphLoaded(); return this.gnn.predict(this.graph); }
    train(target) { this._ensureGraphLoaded(); return this.gnn.train(this.graph, target).loss; }
    
    setLearningRate(value) { this.gnn.learningRate = value; }
    getLearningRate() { return this.gnn.learningRate; }
    setActivation(value) { this.gnn.activationType = value; }
    setLossFunction(value) { this.gnn.lossFunctionType = value; }
}

// ==================== GLOBAL VARIABLES ====================

let facade = null;
let graphState = null;

// ==================== UI FUNCTIONS ====================

function createNetwork() {
    const featureSize = parseInt(document.getElementById('featureSize').value);
    const hiddenSize = parseInt(document.getElementById('hiddenSize').value);
    const outputSize = parseInt(document.getElementById('outputSize').value);
    const numLayers = parseInt(document.getElementById('numLayers').value);
    const activation = document.getElementById('activation').value;
    const lossFunction = document.getElementById('lossFunction').value;
    const learningRate = parseFloat(document.getElementById('learningRate').value);
    
    facade = new GNNFacade(featureSize, hiddenSize, outputSize, numLayers);
    facade.setActivation(activation);
    facade.setLossFunction(lossFunction);
    facade.setLearningRate(learningRate);
    
    document.getElementById('networkStatus').innerText = `Network created! ${numLayers} MP layers, ${facade.getParameterCount()} parameters`;
}

function buildGraph() {
    if (!facade) { alert('Create network first'); return; }
    
    const numNodes = parseInt(document.getElementById('numNodes').value);
    const featureSize = parseInt(document.getElementById('featureSize').value);
    const undirected = document.getElementById('undirected').checked;
    const selfLoops = document.getElementById('selfLoops').checked;
    
    facade.createEmptyGraph(numNodes, featureSize);
    
    // Parse edges
    const edgeText = document.getElementById('edgeList').value;
    const lines = edgeText.trim().split('\n');
    for (const line of lines) {
        const parts = line.trim().split(',');
        if (parts.length === 2) {
            const s = parseInt(parts[0].trim());
            const t = parseInt(parts[1].trim());
            if (!isNaN(s) && !isNaN(t) && s >= 0 && s < numNodes && t >= 0 && t < numNodes) {
                facade.addEdge(s, t, []);
            }
        }
    }
    
    // Randomize features
    for (let i = 0; i < numNodes; i++) {
        const features = Array(featureSize).fill(0).map(() => Math.random());
        facade.setNodeFeatures(i, features);
    }
    
    facade.rebuildAdjacencyList(undirected, selfLoops);
    
    document.getElementById('graphStatus').innerText = `Graph built: ${numNodes} nodes, ${facade.getNumEdges()} edges`;
    drawGraph();
}

function randomizeFeatures() {
    if (!facade || !facade.graphLoaded) { alert('Build graph first'); return; }
    const numNodes = facade.getNumNodes();
    const featureSize = parseInt(document.getElementById('featureSize').value);
    for (let i = 0; i < numNodes; i++) {
        const features = Array(featureSize).fill(0).map(() => Math.random());
        facade.setNodeFeatures(i, features);
    }
    facadeOutput('Features randomized');
}

function trainNetwork() {
    if (!facade || !facade.graphLoaded) { alert('Build graph first'); return; }
    
    const targetText = document.getElementById('targetOutput').value;
    const target = targetText.split(',').map(v => parseFloat(v.trim()));
    const iterations = parseInt(document.getElementById('trainIters').value);
    
    document.getElementById('trainStatus').innerText = `Training for ${iterations} iterations...`;
    
    setTimeout(() => {
        let loss = 0;
        for (let i = 0; i < iterations; i++) {
            loss = facade.train(target);
        }
        document.getElementById('trainStatus').innerText = `Training complete. Final loss: ${loss.toFixed(6)}`;
        drawGraph();
    }, 10);
}

function trainWithProgress() {
    if (!facade || !facade.graphLoaded) { alert('Build graph first'); return; }
    
    const targetText = document.getElementById('targetOutput').value;
    const target = targetText.split(',').map(v => parseFloat(v.trim()));
    const iterations = parseInt(document.getElementById('trainIters').value);
    const progressDiv = document.getElementById('trainingProgress');
    let iter = 0;
    let loss = 0;
    
    function step() {
        if (iter >= iterations) {
            document.getElementById('trainStatus').innerText = `Training complete. Final loss: ${loss.toFixed(6)}`;
            drawGraph();
            return;
        }
        
        loss = facade.train(target);
        iter++;
        
        if (iter % 10 === 0 || iter === iterations) {
            progressDiv.innerHTML = `<div>Iteration: ${iter}/${iterations}, Loss: ${loss.toFixed(6)}</div>
                <div style="width:300px;background:#f0f0f0;border-radius:5px;">
                    <div style="width:${(iter/iterations)*100}%;background:#4CAF50;height:20px;border-radius:5px;"></div>
                </div>`;
        }
        
        setTimeout(step, 0);
    }
    
    document.getElementById('trainStatus').innerText = 'Training...';
    step();
}

function predictOnly() {
    if (!facade || !facade.graphLoaded) { alert('Build graph first'); return; }
    
    const prediction = facade.predict();
    const targetText = document.getElementById('targetOutput').value;
    const target = targetText.split(',').map(v => parseFloat(v.trim()));
    
    document.getElementById('predictOutput').innerHTML = `
        <strong>Prediction:</strong> [${prediction.map(x => x.toFixed(4)).join(', ')}]<br>
        <strong>Target:</strong> [${target.join(', ')}]
    `;
    drawGraph();
}

function drawGraph() {
    if (!facade || !facade.graphLoaded) return;
    
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    const numNodes = facade.getNumNodes();
    
    // Calculate positions in a circle
    const positions = [];
    for (let i = 0; i < numNodes; i++) {
        const angle = (2 * Math.PI * i) / numNodes;
        const radius = Math.min(width, height) * 0.35;
        positions.push({
            x: width / 2 + radius * Math.cos(angle - Math.PI / 2),
            y: height / 2 + radius * Math.sin(angle - Math.PI / 2)
        });
    }
    
    // Draw edges
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 2;
    const undirected = document.getElementById('undirected').checked;
    const drawnEdges = new Set();
    
    for (let i = 0; i < facade.getNumEdges(); i++) {
        const ep = facade.getEdgeEndpoints(i);
        if (!ep) continue;
        
        const key = undirected ? 
            `${Math.min(ep.source, ep.target)}-${Math.max(ep.source, ep.target)}` :
            `${ep.source}-${ep.target}`;
        
        if (drawnEdges.has(key)) continue;
        drawnEdges.add(key);
        
        const p1 = positions[ep.source];
        const p2 = positions[ep.target];
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }
    
    // Draw nodes with embedding magnitude colors
    const embeddings = facade.getFinalNodeEmbeddings();
    const magnitudes = [];
    for (let i = 0; i < numNodes; i++) {
        const emb = embeddings[i] || [];
        magnitudes.push(Math.sqrt(emb.reduce((s, v) => s + v * v, 0)));
    }
    const maxMag = Math.max(...magnitudes, 0.001);
    
    for (let i = 0; i < numNodes; i++) {
        const pos = positions[i];
        const normMag = magnitudes[i] / maxMag;
        
        const r = Math.round(68 + normMag * 120);
        const g = Math.round(119 - normMag * 50);
        const b = Math.round(200 - normMag * 100);
        
        ctx.fillStyle = facade.getNodeMask(i) ? `rgb(${r}, ${g}, ${b})` : '#ccc';
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 18, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i.toString(), pos.x, pos.y);
    }
}

// ==================== FACADE UI FUNCTIONS ====================

function getFacadeParams() {
    return {
        nodeIdx: parseInt(document.getElementById('facadeNodeIdx').value),
        edgeIdx: parseInt(document.getElementById('facadeEdgeIdx').value),
        layerIdx: parseInt(document.getElementById('facadeLayerIdx').value),
        featureIdx: parseInt(document.getElementById('facadeFeatureIdx').value),
        neighborIdx: parseInt(document.getElementById('facadeNeighborIdx').value),
        neuronIdx: parseInt(document.getElementById('facadeNeuronIdx').value),
        weightIdx: parseInt(document.getElementById('facadeWeightIdx').value),
        value: parseFloat(document.getElementById('facadeSetValue').value)
    };
}

function facadeOutput(msg) {
    document.getElementById('facadeOutput').innerText = msg;
}

// 1. Node & Edge Features
function facadeGetNodeFeature() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].feature[${p.featureIdx}] = ${facade.getNodeFeature(p.nodeIdx, p.featureIdx)}`);
}

function facadeGetNodeFeatures() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const features = facade.getNodeFeatures(p.nodeIdx);
    facadeOutput(`Node[${p.nodeIdx}].features = [\n  ${features.map(f => f.toFixed(4)).join(',\n  ')}\n]`);
}

function facadeGetEdgeFeatures() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const features = facade.getEdgeFeatures(p.edgeIdx);
    facadeOutput(`Edge[${p.edgeIdx}].features = [${features.map(f => f.toFixed(4)).join(', ')}]`);
}

function facadeGetNumNodes() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Number of nodes = ${facade.getNumNodes()}`);
}

function facadeGetNumEdges() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Number of edges = ${facade.getNumEdges()}`);
}

// 2. Topology
function facadeGetNeighbors() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const neighbors = facade.getNeighbors(p.nodeIdx);
    facadeOutput(`Node[${p.nodeIdx}].neighbors = [${neighbors.join(', ')}]`);
}

function facadeGetAdjacencyMatrix() {
    if (!facade) { alert('Create network first'); return; }
    const matrix = facade.getAdjacencyMatrix();
    let s = 'Adjacency Matrix:\n';
    for (let i = 0; i < matrix.length; i++) {
        s += `  [${matrix[i].join(', ')}]\n`;
    }
    facadeOutput(s);
}

function facadeGetEdgeEndpoints() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const ep = facade.getEdgeEndpoints(p.edgeIdx);
    facadeOutput(`Edge[${p.edgeIdx}] = ${ep ? `${ep.source} -> ${ep.target}` : 'not found'}`);
}

function facadeHasEdge() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Has edge ${p.nodeIdx} -> ${p.neighborIdx}? ${facade.hasEdge(p.nodeIdx, p.neighborIdx)}`);
}

function facadeGetInDegree() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].inDegree = ${facade.getInDegree(p.nodeIdx)}`);
}

function facadeGetOutDegree() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].outDegree = ${facade.getOutDegree(p.nodeIdx)}`);
}

// 3. Embeddings
function facadeGetNodeEmbedding() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const emb = facade.getNodeEmbedding(p.layerIdx, p.nodeIdx);
    facadeOutput(`Node[${p.nodeIdx}] embedding at layer ${p.layerIdx}:\n[${emb.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetAllNodeEmbeddings() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const embs = facade.getAllNodeEmbeddings(p.nodeIdx);
    let s = `All embeddings for Node[${p.nodeIdx}]:\n`;
    embs.forEach((e, i) => {
        s += `  Layer ${i}: [${e.slice(0, 4).map(v => v.toFixed(3)).join(', ')}${e.length > 4 ? '...' : ''}]\n`;
    });
    facadeOutput(s);
}

function facadeGetFinalEmbeddings() {
    if (!facade) { alert('Create network first'); return; }
    const embs = facade.getFinalNodeEmbeddings();
    let s = 'Final Node Embeddings:\n';
    embs.forEach((e, i) => {
        s += `  Node ${i}: [${e.slice(0, 4).map(v => v.toFixed(3)).join(', ')}${e.length > 4 ? '...' : ''}]\n`;
    });
    facadeOutput(s);
}

function facadeGetEdgeEmbedding() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const emb = facade.getEdgeEmbedding(p.layerIdx, p.edgeIdx);
    facadeOutput(`Edge[${p.edgeIdx}] embedding at layer ${p.layerIdx}:\n[${emb.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetCurrentNodeEmbedding() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const emb = facade.getCurrentNodeEmbedding(p.nodeIdx);
    facadeOutput(`Node[${p.nodeIdx}] current embedding:\n[${emb.map(v => v.toFixed(4)).join(', ')}]`);
}

// 4. Message Passing
function facadeGetMessage() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const msg = facade.getMessage(p.nodeIdx, p.neighborIdx, p.layerIdx);
    facadeOutput(`Message from Node[${p.nodeIdx}] to Neighbor[${p.neighborIdx}] at layer ${p.layerIdx}:\n[${msg.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetAggregatedMessage() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const msg = facade.getAggregatedMessage(p.nodeIdx, p.layerIdx);
    facadeOutput(`Aggregated message for Node[${p.nodeIdx}] at layer ${p.layerIdx}:\n[${msg.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetMessageInput() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const input = facade.getMessageInput(p.nodeIdx, p.neighborIdx, p.layerIdx);
    facadeOutput(`Message input for Node[${p.nodeIdx}] -> Neighbor[${p.neighborIdx}] at layer ${p.layerIdx}:\n[${input.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetNumMessages() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Number of messages for Node[${p.nodeIdx}] at layer ${p.layerIdx} = ${facade.getNumMessagesForNode(p.nodeIdx, p.layerIdx)}`);
}

// 5. Readout & Output
function facadeGetGraphEmbedding() {
    if (!facade) { alert('Create network first'); return; }
    const emb = facade.getGraphEmbedding();
    facadeOutput(`Graph embedding:\n[${emb.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetReadoutOutput() {
    if (!facade) { alert('Create network first'); return; }
    const out = facade.getReadoutLayerOutput();
    facadeOutput(`Readout layer output:\n[${out.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetOutputLayerOutput() {
    if (!facade) { alert('Create network first'); return; }
    const out = facade.getOutputLayerOutput();
    facadeOutput(`Output layer output:\n[${out.map(v => v.toFixed(4)).join(', ')}]`);
}

function facadeGetPreActivations() {
    if (!facade) { alert('Create network first'); return; }
    const readout = facade.getReadoutLayerPreActivations();
    const output = facade.getOutputLayerPreActivations();
    facadeOutput(`Readout pre-activations: [${readout.map(v => v.toFixed(4)).join(', ')}]\nOutput pre-activations: [${output.map(v => v.toFixed(4)).join(', ')}]`);
}

// 6. Gradients & Weights
function facadeGetWeightGradient() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Weight gradient [${p.layerIdx}][${p.neuronIdx}][${p.weightIdx}] = ${facade.getWeightGradient(p.layerIdx, p.neuronIdx, p.weightIdx)}`);
}

function facadeGetBiasGradient() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Bias gradient [${p.layerIdx}][${p.neuronIdx}] = ${facade.getBiasGradient(p.layerIdx, p.neuronIdx)}`);
}

function facadeGetMessageLayerWeight() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Message layer [${p.layerIdx}] weight [${p.neuronIdx}][${p.weightIdx}] = ${facade.getMessageLayerWeight(p.layerIdx, p.neuronIdx, p.weightIdx)}`);
}

function facadeGetUpdateLayerWeight() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Update layer [${p.layerIdx}] weight [${p.neuronIdx}][${p.weightIdx}] = ${facade.getUpdateLayerWeight(p.layerIdx, p.neuronIdx, p.weightIdx)}`);
}

function facadeGetGradientFlow() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const flow = facade.getGradientFlow(p.layerIdx);
    facadeOutput(`Gradient flow for layer ${p.layerIdx}:\n${JSON.stringify(flow, null, 2)}`);
}

function facadeGetAllGradientFlows() {
    if (!facade) { alert('Create network first'); return; }
    const flows = facade.getAllGradientFlows();
    let s = 'All gradient flows:\n';
    flows.forEach(f => {
        s += `Layer ${f.layerIdx}: mean=${f.meanGradient.toFixed(6)}, norm=${f.gradientNorm.toFixed(6)}\n`;
    });
    facadeOutput(s);
}

// 7. Masking
function facadeGetNodeMask() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].mask = ${facade.getNodeMask(p.nodeIdx)}`);
}

function facadeSetNodeMask() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const current = facade.getNodeMask(p.nodeIdx);
    facade.setNodeMask(p.nodeIdx, !current);
    facadeOutput(`Node[${p.nodeIdx}].mask toggled to ${!current}`);
    drawGraph();
}

function facadeApplyNodeDropout() {
    if (!facade) { alert('Create network first'); return; }
    facade.applyDropoutToNodes(0.3);
    facadeOutput(`Applied 30% node dropout. Masked nodes: ${facade.getMaskedNodeCount()}`);
    drawGraph();
}

function facadeApplyEdgeDropout() {
    if (!facade) { alert('Create network first'); return; }
    facade.applyDropoutToEdges(0.3);
    facadeOutput(`Applied 30% edge dropout. Masked edges: ${facade.getMaskedEdgeCount()}`);
}

function facadeGetMaskedCounts() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Masked nodes: ${facade.getMaskedNodeCount()}\nMasked edges: ${facade.getMaskedEdgeCount()}`);
}

// 8. Graph Mutation
function facadeAddNode() {
    if (!facade) { alert('Create network first'); return; }
    const featuresText = document.getElementById('newNodeFeatures').value;
    const features = featuresText.split(',').map(v => parseFloat(v.trim()));
    const idx = facade.addNode(features);
    facadeOutput(`Added node at index ${idx}. Total nodes: ${facade.getNumNodes()}`);
    drawGraph();
}

function facadeRemoveNode() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facade.removeNode(p.nodeIdx);
    facadeOutput(`Removed node ${p.nodeIdx}. Total nodes: ${facade.getNumNodes()}`);
    drawGraph();
}

function facadeAddEdge() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const idx = facade.addEdge(p.nodeIdx, p.neighborIdx, []);
    facadeOutput(`Added edge ${p.nodeIdx} -> ${p.neighborIdx} at index ${idx}. Total edges: ${facade.getNumEdges()}`);
    drawGraph();
}

function facadeRemoveEdge() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facade.removeEdge(p.edgeIdx);
    facadeOutput(`Removed edge ${p.edgeIdx}. Total edges: ${facade.getNumEdges()}`);
    drawGraph();
}

function facadeClearEdges() {
    if (!facade) { alert('Create network first'); return; }
    facade.clearAllEdges();
    facadeOutput('Cleared all edges');
    drawGraph();
}

function facadeRebuildAdjacency() {
    if (!facade) { alert('Create network first'); return; }
    const undirected = document.getElementById('undirected').checked;
    const selfLoops = document.getElementById('selfLoops').checked;
    facade.rebuildAdjacencyList(undirected, selfLoops);
    facadeOutput(`Rebuilt adjacency list (undirected=${undirected}, selfLoops=${selfLoops})`);
}

// 9. Diagnostics
function facadeGetNodeDegree() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].degree = ${facade.getNodeDegree(p.nodeIdx)}`);
}

function facadeGetGraphCentrality() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].degreeCentrality = ${facade.getGraphCentrality(p.nodeIdx).toFixed(4)}`);
}

function facadeGetBetweennessCentrality() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].betweennessCentrality = ${facade.getBetweennessCentrality(p.nodeIdx).toFixed(4)}`);
}

function facadeGetClosenessCentrality() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Node[${p.nodeIdx}].closenessCentrality = ${facade.getClosenessCentrality(p.nodeIdx).toFixed(4)}`);
}

function facadeGetAttentionWeight() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Attention weight Node[${p.nodeIdx}] -> Neighbor[${p.neighborIdx}] at layer ${p.layerIdx} = ${facade.getAttentionWeight(p.nodeIdx, p.neighborIdx, p.layerIdx).toFixed(4)}`);
}

function facadeComputePageRank() {
    if (!facade) { alert('Create network first'); return; }
    const ranks = facade.computePageRank();
    let s = 'PageRank:\n';
    ranks.forEach((r, i) => s += `  Node ${i}: ${r.toFixed(4)}\n`);
    facadeOutput(s);
}

function facadeGetFeatureImportance() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(`Feature importance Node[${p.nodeIdx}][${p.featureIdx}] = ${facade.getFeatureImportance(p.nodeIdx, p.featureIdx).toFixed(4)}`);
}

// 10. Batch
function facadeAddToBatch() {
    if (!facade || !facade.graphLoaded) { alert('Build graph first'); return; }
    facade.addGraphToBatch(facade.getGraph());
    facadeOutput(`Added graph to batch. Batch size: ${facade.getBatchSize()}`);
}

function facadeGetBatchSize() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Batch size = ${facade.getBatchSize()}`);
}

function facadeClearBatch() {
    if (!facade) { alert('Create network first'); return; }
    facade.clearBatch();
    facadeOutput('Batch cleared');
}

function facadeGetBatchPredictions() {
    if (!facade) { alert('Create network first'); return; }
    const preds = facade.getBatchPredictions();
    let s = 'Batch predictions:\n';
    preds.forEach((p, i) => s += `  Graph ${i}: [${p.map(v => v.toFixed(4)).join(', ')}]\n`);
    facadeOutput(s);
}

// 11. Export
function facadeExportGraphJSON() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(facade.exportGraphToJSON());
}

function facadeExportEmbeddingsCSV() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facadeOutput(facade.exportEmbeddingsToCSV(p.layerIdx));
}

function facadeShowActivationHistogram() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const hist = facade.getActivationHistogram(p.layerIdx);
    renderHistogram(hist, `Activation Histogram for Layer ${p.layerIdx}`);
}

function renderHistogram(hist, title) {
    const maxVal = Math.max(...hist, 0.001);
    const bars = hist.map((v, i) => {
        const height = (v / maxVal) * 100;
        return `<div class="histogram-bar" style="height:${height}%" title="Bin ${i}: ${(v * 100).toFixed(1)}%"></div>`;
    }).join('');
    document.getElementById('histogramDisplay').innerHTML = `<strong>${title}</strong><div class="histogram-container">${bars}</div>`;
}

// 12. Architecture
function facadeGetLayerConfig() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    const config = facade.getLayerConfig(p.layerIdx);
    facadeOutput(`Layer ${p.layerIdx} config:\n${JSON.stringify(config, null, 2)}`);
}

function facadeGetNumMPLayers() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Number of message passing layers = ${facade.getNumMessagePassingLayers()}`);
}

function facadeGetTotalLayers() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Total layers = ${facade.getTotalLayerCount()}`);
}

function facadeGetParameterCount() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(`Total parameters = ${facade.getParameterCount()}`);
}

function facadeGetArchitectureSummary() {
    if (!facade) { alert('Create network first'); return; }
    facadeOutput(facade.getArchitectureSummary());
}

// Setters
function facadeSetNodeFeature() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facade.setNodeFeature(p.nodeIdx, p.featureIdx, p.value);
    facadeOutput(`Set Node[${p.nodeIdx}].feature[${p.featureIdx}] = ${p.value}`);
}

function facadeSetMessageLayerWeight() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facade.setMessageLayerWeight(p.layerIdx, p.neuronIdx, p.weightIdx, p.value);
    facadeOutput(`Set Message layer [${p.layerIdx}] weight [${p.neuronIdx}][${p.weightIdx}] = ${p.value}`);
}

function facadeSetLearningRate() {
    if (!facade) { alert('Create network first'); return; }
    const p = getFacadeParams();
    facade.setLearningRate(p.value);
    facadeOutput(`Set learning rate = ${p.value}`);
}

// ==================== CSV IMPORT FUNCTIONS ====================

let trainingTargets = [];

function loadNodesCsv(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        document.getElementById('nodesCsvText').value = e.target.result;
    };
    reader.readAsText(file);
}

function loadEdgesCsv(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        document.getElementById('edgesCsvText').value = e.target.result;
    };
    reader.readAsText(file);
}

function loadTargetsCsv(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        document.getElementById('targetsCsvText').value = e.target.result;
    };
    reader.readAsText(file);
}

function parseCSV(text, skipHeader = false) {
    const lines = text.trim().split('\n').filter(line => line.trim());
    if (lines.length === 0) return [];
    
    // Check if first line looks like a header (contains non-numeric values)
    const firstLine = lines[0].split(',').map(v => v.trim());
    const isHeader = skipHeader || firstLine.some(v => isNaN(parseFloat(v)) && v !== '');
    
    const startIdx = isHeader ? 1 : 0;
    const result = [];
    
    for (let i = startIdx; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim());
        result.push(values);
    }
    
    return result;
}

function importFromCsv() {
    if (!facade) { 
        alert('Create network first'); 
        return; 
    }
    
    const nodesText = document.getElementById('nodesCsvText').value.trim();
    const edgesText = document.getElementById('edgesCsvText').value.trim();
    const targetsText = document.getElementById('targetsCsvText').value.trim();
    
    let imported = [];
    
    // Parse and apply node features
    if (nodesText) {
        const nodesData = parseCSV(nodesText);
        if (nodesData.length > 0) {
            // Determine if first column is node ID or feature
            const firstRowFirstVal = parseFloat(nodesData[0][0]);
            const hasNodeId = Number.isInteger(firstRowFirstVal) && firstRowFirstVal >= 0 && firstRowFirstVal < nodesData.length;
            
            const numNodes = nodesData.length;
            const featureSize = hasNodeId ? nodesData[0].length - 1 : nodesData[0].length;
            
            // Update UI
            document.getElementById('numNodes').value = numNodes;
            document.getElementById('featureSize').value = featureSize;
            
            // Create graph if needed
            if (!facade.graphLoaded || facade.getNumNodes() !== numNodes) {
                facade.createEmptyGraph(numNodes, featureSize);
            }
            
            // Apply features
            for (let i = 0; i < nodesData.length; i++) {
                const row = nodesData[i];
                const startIdx = hasNodeId ? 1 : 0;
                const nodeIdx = hasNodeId ? parseInt(row[0]) : i;
                const features = row.slice(startIdx).map(v => parseFloat(v) || 0);
                
                if (nodeIdx >= 0 && nodeIdx < numNodes) {
                    facade.setNodeFeatures(nodeIdx, features);
                }
            }
            
            imported.push(`${numNodes} nodes with ${featureSize} features`);
        }
    }
    
    // Parse and apply edges
    if (edgesText) {
        const edgesData = parseCSV(edgesText);
        if (edgesData.length > 0) {
            // Clear existing edges
            if (facade.graphLoaded) {
                facade.clearAllEdges();
            }
            
            let edgeCount = 0;
            for (const row of edgesData) {
                if (row.length >= 2) {
                    const source = parseInt(row[0]);
                    const target = parseInt(row[1]);
                    const numNodes = facade.getNumNodes();
                    
                    if (!isNaN(source) && !isNaN(target) && 
                        source >= 0 && source < numNodes && 
                        target >= 0 && target < numNodes) {
                        facade.addEdge(source, target, []);
                        edgeCount++;
                    }
                }
            }
            
            // Update edge list textarea
            document.getElementById('edgeList').value = edgesData
                .filter(r => r.length >= 2)
                .map(r => `${r[0]},${r[1]}`)
                .join('\n');
            
            // Rebuild adjacency
            const undirected = document.getElementById('undirected').checked;
            const selfLoops = document.getElementById('selfLoops').checked;
            facade.rebuildAdjacencyList(undirected, selfLoops);
            
            imported.push(`${edgeCount} edges`);
        }
    }
    
    // Parse training targets
    if (targetsText) {
        const targetsData = parseCSV(targetsText);
        trainingTargets = [];
        
        for (const row of targetsData) {
            const target = row.map(v => parseFloat(v) || 0);
            if (target.length > 0) {
                trainingTargets.push(target);
            }
        }
        
        // Update target output field with first target
        if (trainingTargets.length > 0) {
            document.getElementById('targetOutput').value = trainingTargets[0].join(',');
        }
        
        imported.push(`${trainingTargets.length} training targets`);
    }
    
    if (imported.length > 0) {
        document.getElementById('csvImportStatus').innerText = `Imported: ${imported.join(', ')}`;
        updateCsvTargetsInfo();
        drawGraph();
    } else {
        document.getElementById('csvImportStatus').innerText = 'No data to import';
    }
}

function clearCsvInputs() {
    document.getElementById('nodesCsvText').value = '';
    document.getElementById('edgesCsvText').value = '';
    document.getElementById('targetsCsvText').value = '';
    document.getElementById('nodesCsvFile').value = '';
    document.getElementById('edgesCsvFile').value = '';
    document.getElementById('targetsCsvFile').value = '';
    trainingTargets = [];
    document.getElementById('csvImportStatus').innerText = 'CSV inputs cleared';
}

// ==================== MANUAL INPUT FUNCTIONS ====================

function applyManualFeatures() {
    if (!facade || !facade.graphLoaded) { 
        alert('Build graph first'); 
        return; 
    }
    
    const text = document.getElementById('manualNodeFeatures').value.trim();
    if (!text) {
        document.getElementById('manualFeaturesStatus').innerText = 'No features entered';
        return;
    }
    
    const lines = text.split('\n').filter(line => line.trim());
    const numNodes = facade.getNumNodes();
    let applied = 0;
    
    for (let i = 0; i < Math.min(lines.length, numNodes); i++) {
        const features = lines[i].split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
        if (features.length > 0) {
            facade.setNodeFeatures(i, features);
            applied++;
        }
    }
    
    document.getElementById('manualFeaturesStatus').innerText = `Applied features to ${applied} nodes`;
    drawGraph();
}

function loadCurrentFeatures() {
    if (!facade || !facade.graphLoaded) { 
        alert('Build graph first'); 
        return; 
    }
    
    const numNodes = facade.getNumNodes();
    const lines = [];
    
    for (let i = 0; i < numNodes; i++) {
        const features = facade.getNodeFeatures(i);
        lines.push(features.map(f => f.toFixed(4)).join(','));
    }
    
    document.getElementById('manualNodeFeatures').value = lines.join('\n');
    document.getElementById('manualFeaturesStatus').innerText = `Loaded features from ${numNodes} nodes`;
}

// ==================== BATCH TRAINING WITH CSV TARGETS ====================

function trainWithCsvTargets() {
    if (!facade || !facade.graphLoaded) { 
        alert('Build graph first'); 
        return; 
    }
    
    if (trainingTargets.length === 0) {
        alert('No training targets loaded. Import targets from CSV first.');
        return;
    }
    
    const iterations = parseInt(document.getElementById('trainIters').value);
    const progressDiv = document.getElementById('trainingProgress');
    let totalLoss = 0;
    
    document.getElementById('trainStatus').innerText = `Training with ${trainingTargets.length} targets for ${iterations} iterations...`;
    
    setTimeout(() => {
        for (let iter = 0; iter < iterations; iter++) {
            for (const target of trainingTargets) {
                totalLoss = facade.train(target);
            }
        }
        
        document.getElementById('trainStatus').innerText = 
            `Training complete. Final loss: ${totalLoss.toFixed(6)} (${trainingTargets.length} targets Ã— ${iterations} iterations)`;
        drawGraph();
    }, 10);
}

// ==================== CUSTOM PREDICTION INPUT ====================

function predictWithCustomInput() {
    if (!facade) { 
        alert('Create network first'); 
        return; 
    }
    
    const featuresText = document.getElementById('predictInputFeatures').value.trim();
    const edgesText = document.getElementById('predictInputEdges').value.trim();
    
    if (!featuresText) {
        document.getElementById('predictOutput').innerHTML = '<div class="error-msg">Please enter node features</div>';
        return;
    }
    
    // Parse features
    const lines = featuresText.split('\n').filter(line => line.trim());
    const nodeFeatures = lines.map(line => 
        line.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v))
    );
    
    if (nodeFeatures.length === 0 || nodeFeatures[0].length === 0) {
        document.getElementById('predictOutput').innerHTML = '<div class="error-msg">Invalid node features format</div>';
        return;
    }
    
    const numNodes = nodeFeatures.length;
    const featureSize = nodeFeatures[0].length;
    
    // Create temporary graph
    facade.createEmptyGraph(numNodes, featureSize);
    
    // Apply features
    for (let i = 0; i < numNodes; i++) {
        facade.setNodeFeatures(i, nodeFeatures[i]);
    }
    
    // Parse and add edges
    if (edgesText) {
        const edgePairs = edgesText.split(';').map(e => e.trim()).filter(e => e);
        for (const pair of edgePairs) {
            const parts = pair.split(',');
            if (parts.length === 2) {
                const source = parseInt(parts[0].trim());
                const target = parseInt(parts[1].trim());
                if (!isNaN(source) && !isNaN(target) && 
                    source >= 0 && source < numNodes && 
                    target >= 0 && target < numNodes) {
                    facade.addEdge(source, target, []);
                }
            }
        }
    } else {
        // Create default fully connected graph
        for (let i = 0; i < numNodes; i++) {
            for (let j = i + 1; j < numNodes; j++) {
                facade.addEdge(i, j, []);
            }
        }
    }
    
    // Rebuild adjacency
    const undirected = document.getElementById('undirected').checked;
    const selfLoops = document.getElementById('selfLoops').checked;
    facade.rebuildAdjacencyList(undirected, selfLoops);
    
    // Run prediction
    const prediction = facade.predict();
    const targetText = document.getElementById('targetOutput').value;
    const target = targetText.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
    
    document.getElementById('predictOutput').innerHTML = `
        <strong>Custom Input Prediction</strong><br>
        <strong>Nodes:</strong> ${numNodes} (${featureSize} features each)<br>
        <strong>Edges:</strong> ${facade.getNumEdges()}<br>
        <strong>Prediction:</strong> [${prediction.map(x => x.toFixed(4)).join(', ')}]<br>
        <strong>Target:</strong> [${target.join(', ')}]
    `;
    
    drawGraph();
}

// Update CSV targets info when importing
function updateCsvTargetsInfo() {
    const infoDiv = document.getElementById('csvTargetsInfo');
    if (trainingTargets.length > 0) {
        infoDiv.innerText = `${trainingTargets.length} training targets loaded from CSV`;
    } else {
        infoDiv.innerText = '';
    }
}
</script>
</body>
</html>
